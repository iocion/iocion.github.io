!!! info "QWQ"
    作者已经在更新了.....
buff1 和buff2进行，各个位置相加，不考虑溢出，完成对应项的求和保存在sum中
```asm
data segement
	buff1 db -1,2,32,342.....
	buff2 db  -1,3,3,4,5,5,6.....
	sum  db 10dup(0)
data ends
-------------------------------------
code segement
main proc far
	assume ds:data cs:code
-------------------------------------
start:
	push dx
	sub ax,ax  ; ax清零
	push ax
	mov ax,data
	mov ds,ax
	lea si, buff1
	lea di, buff2
	lea bx,sum    ; 用来存放sum的值
	mov cx,10  ; 设置循环次数
next:
	mov al,[si]
	add al,[di]
	mov [bx],al
	inc si
	inc di
	inc bx
	loop next 
	ret 
	main endp
code ends
end main
```
加密程序
```asm
data segement
	str db "dkfjaklflalf121"  ; 总共二十个字符
data ends
code segement
main proc far 
	assume ds:data,cs:code
start:
	push dx
	sub ax,ax
	push ax
	# mov ax,data
	# mov ds,ax
	lea si,str
	mov cx,20 ;设置循环次数
	call jiami ; call function
	ret 
	main endp
	;加密子程序
jiami proc near
     l1: cmp [si],'A'
	 	 jb l2
	 	 cmp [si],'Z'
	 	 ja l3
	 	 add byte ptr [si],20H
	 	 jmp l4
	 l2:
	  	 add byte ptr [si],1
	  	 jmp l4
	 l3:
	 	 sub byte ptr  [si],20H
	 l4:	
	 	 inc si
	 	 loop l1
	 	 ret
	 jiami endp
	 code  ends
	 	end main
```

```
数字的十六进制是 0-9  
30h-39h
小写字母的十六进制是 a-z
61h-7ah
大写字母的十六进制是 A-Z
41h-5ah
小写转大写字母：sub byte ptr  [si],20H
```